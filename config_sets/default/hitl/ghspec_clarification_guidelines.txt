# GHSpec HITL Clarification Guidelines

**Purpose**: Meta-level guidelines for handling ambiguous requirements during specification generation

**Why GHSpec Needs Different HITL Than ChatDev/BAEs**:
- ChatDev/BAEs receive a complete specification upfront (`expanded_spec.txt`)
- GHSpec **generates** the specification incrementally through phases (specify → plan → tasks)
- When GHSpec's AI encounters unclear requirements during specification generation, it needs guidelines on:
  - What assumptions to make
  - What details to include/exclude
  - When to mark something as needing clarification vs. using reasonable defaults

**Usage**: When GHSpec adapter detects clarification requests during specification/planning phases 
(e.g., `[NEEDS CLARIFICATION: ...]`), respond with these guidelines to maintain reproducibility.

---

## Expanded Feature Requirements

Thank you for seeking clarification. Here is additional context to help you complete the specification:

### User Experience Priorities

- **Primary Users**: The target users are developers and technical teams who will interact with this feature daily
- **Experience Level**: Assume users have basic technical competency but may not be domain experts
- **Accessibility**: The feature should work across common platforms (web browsers, modern mobile devices)
- **Performance**: Users expect responsive interactions (< 2 second response time for most operations)

### Data Handling

- **Data Persistence**: Unless explicitly stated as ephemeral, assume data should be persisted to a database
- **Data Validation**: Apply industry-standard validation rules:
  - Email addresses: RFC 5322 format
  - Passwords: Minimum 8 characters, include uppercase, lowercase, and number
  - URLs: Valid HTTP/HTTPS format
  - Dates: ISO 8601 format
  - Numbers: Validate ranges and precision as appropriate for the use case

- **Data Privacy**: 
  - Never log sensitive data (passwords, tokens, PII)
  - Assume GDPR/CCPA compliance requirements
  - Support data deletion/export if user data is involved

### Security Assumptions

- **Authentication**: If the feature involves user accounts, assume token-based authentication (JWT or similar)
- **Authorization**: Apply principle of least privilege - users can only access their own data unless explicitly sharing
- **Input Sanitization**: All user inputs must be sanitized to prevent injection attacks
- **Rate Limiting**: Apply reasonable rate limits (e.g., 100 requests/minute per user) for API endpoints
- **HTTPS**: Assume all production traffic uses HTTPS

### Error Handling

- **User-Facing Errors**: Return clear, actionable error messages (e.g., "Email already registered" not "Database constraint violation")
- **Logging**: Log all errors with sufficient context for debugging (timestamp, user ID if applicable, stack trace)
- **Graceful Degradation**: If optional features fail, core functionality should continue working
- **Retry Logic**: For transient failures (network, external APIs), implement exponential backoff (3 attempts)

### Integration Points

- **External APIs**: If integrating with external services, assume:
  - Services may be temporarily unavailable (handle with retries and fallbacks)
  - API keys/credentials stored securely (environment variables, not hardcoded)
  - Rate limits exist (implement request throttling)

- **Email**: If sending emails:
  - Use transactional email service (SendGrid, AWS SES, etc.)
  - Include unsubscribe links where legally required
  - Handle bounces and failures gracefully

- **File Uploads**: If accepting files:
  - Maximum size: 10MB per file (unless spec states otherwise)
  - Allowed types: Common formats (PDF, JPG, PNG, DOC, TXT) unless restricted
  - Virus scanning required for production
  - Store in object storage (S3, Azure Blob) not filesystem

### Scalability & Performance

- **Expected Load**: Design for 1000 concurrent users initially, with ability to scale horizontally
- **Database**: Use indexes for frequently queried fields
- **Caching**: Cache frequently accessed, rarely changing data (e.g., user profiles, configuration)
- **Async Operations**: Long-running tasks (>5 seconds) should be asynchronous with progress indicators

### Testing Requirements

- **Unit Tests**: Aim for 80%+ code coverage
- **Integration Tests**: Test critical user flows end-to-end
- **Test Data**: Use factories/fixtures for test data, never production data
- **CI/CD**: Tests must run in CI pipeline and pass before deployment

### Deployment Assumptions

- **Environment**: Support development, staging, and production environments
- **Configuration**: Environment-specific settings via environment variables
- **Migrations**: Database schema changes via versioned migrations (Alembic, Flyway, etc.)
- **Rollback**: Ability to rollback to previous version if deployment fails

### Documentation

- **API Documentation**: Auto-generated from code (Swagger/OpenAPI for REST APIs)
- **README**: Include setup instructions, configuration options, common troubleshooting
- **Inline Comments**: Explain complex business logic, not obvious code

### Non-Functional Requirements

- **Browser Compatibility**: Last 2 versions of Chrome, Firefox, Safari, Edge (if web UI)
- **Mobile**: Responsive design for tablets and phones (if web UI)
- **Internationalization**: Initially English only, but structure code to support future localization
- **Monitoring**: Log key metrics (request count, error rate, latency) for observability

### Reasonable Defaults

When specification doesn't explicitly state details, use these defaults:

- **Pagination**: 20 items per page, max 100
- **Timeouts**: 30 seconds for API requests, 5 minutes for background jobs
- **Session Duration**: 24 hours for authenticated sessions
- **Password Reset**: Tokens expire after 1 hour
- **File Names**: Sanitize to alphanumeric + underscores + hyphens
- **Timestamps**: Store in UTC, display in user's timezone
- **Soft Deletes**: Use soft deletes for user data (mark as deleted, don't actually remove)

---

## Clarification Policy

**When to Mark [NEEDS CLARIFICATION]**:
- Feature scope is fundamentally ambiguous (affects what gets built)
- Multiple reasonable interpretations with significantly different implementations
- Security/privacy implications unclear
- User experience critically depends on unclear detail

**When to Make Assumptions**:
- Minor details that don't affect core functionality
- Industry-standard practices can be applied
- Reasonable defaults exist
- Details can be refined in later iterations

**Document Assumptions**: Always list assumptions in the specification's "Assumptions" section so they can be validated later.

---

This expanded specification should resolve most clarifications. Proceed with reasonable assumptions for any remaining minor details, and document them in the specification.

---

## Iteration 2: Additional Clarification

If you're still encountering ambiguity after the initial guidelines, here are additional considerations:

### More Specific Guidance

- **Trade-offs**: When multiple valid approaches exist, prioritize in this order:
  1. **Security first**: Choose the more secure option
  2. **User experience**: Choose the approach that reduces friction
  3. **Maintainability**: Choose simpler, more maintainable solutions
  4. **Performance**: Optimize only if there's a clear need

- **Scope Boundaries**: If uncertain whether a feature should be included:
  - **Include** if it's necessary for the core user story to be valuable
  - **Exclude** if it's a "nice to have" or future enhancement
  - Document excluded items in "Future Enhancements" section

- **Technology Choices**: If multiple technologies could work:
  - Prefer widely-adopted, well-documented options
  - Prefer managed services over self-hosted (reduces operational complexity)
  - Match the team's existing technology stack when possible

### Handling Edge Cases

- **Error States**: For each operation, consider:
  - What happens if network fails?
  - What happens if resource doesn't exist?
  - What happens if user lacks permissions?
  - Document error handling strategy in specification

- **Boundary Conditions**: Consider limits:
  - Empty collections (0 items)
  - Very large collections (1000+ items)
  - Concurrent access (multiple users editing same resource)
  - Document assumptions about limits

### Integration Details

If integration points are unclear:
- **Default to REST APIs** with JSON for service-to-service communication
- **Use webhooks** for event notifications rather than polling
- **Include retry logic** with exponential backoff for all external calls
- **Require authentication** for all API endpoints unless explicitly public

---

## Iteration 3: Final Clarification

If ambiguity persists after two rounds, apply these final decision rules:

### Decision Heuristics

1. **When in doubt, build less**: Start with minimal viable feature set. It's easier to add than remove.

2. **Explicit over implicit**: Require explicit user actions rather than assuming intent.

3. **Fail loudly**: Return errors rather than silently handling unexpected situations.

4. **Standard patterns**: Use established design patterns and industry conventions.

### Proceeding with Best-Effort

At this point, you have sufficient guidance to proceed. Make your best judgment based on:
- The original feature description
- These three rounds of clarification guidelines
- Industry best practices for similar features

**Document all assumptions prominently** in the specification's "Assumptions & Decisions" section, including:
- What was unclear
- What assumption you made
- Why you made that choice
- What alternative was considered

This allows assumptions to be reviewed and adjusted if needed before implementation.

---

**Note**: If after three clarification iterations the specification still cannot be reasonably completed, log a warning and proceed with conservative assumptions that minimize risk and scope.
